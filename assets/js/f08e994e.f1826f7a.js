"use strict";(self.webpackChunkliveviewjs_com=self.webpackChunkliveviewjs_com||[]).push([[333],{876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>v});var o=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=o.createContext({}),s=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return o.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),v=i,u=d["".concat(p,".").concat(v)]||d[v]||m[v]||a;return n?o.createElement(u,r(r({ref:t},c),{},{components:n})):o.createElement(u,r({ref:t},c))}));function v(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4969:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var o=n(7896),i=(n(2784),n(876));const a={sidebar_position:2},r="Live Components",l={unversionedId:"misc/livecomponents",id:"misc/livecomponents",title:"Live Components",description:"We've mostly been talking about LiveViews, but LiveViewJS also supports LiveComponents. Live Components are a way",source:"@site/docs/13-misc/livecomponents.md",sourceDirName:"13-misc",slug:"/misc/livecomponents",permalink:"/docs/misc/livecomponents",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Security Topics",permalink:"/docs/misc/security-topics"},next:{title:"Statics and Dynamics",permalink:"/docs/misc/statics-and-dynamics"}},p={},s=[{value:"LiveComponent API",id:"livecomponent-api",level:2},{value:"Stateful vs Stateless",id:"stateful-vs-stateless",level:3},{value:"Lifecycle Differences",id:"lifecycle-differences",level:3},{value:"Stateful LiveComponent <code>handleEvent</code>",id:"stateful-livecomponent-handleevent",level:3},{value:"Adding a LiveComponent to a LiveView",id:"adding-a-livecomponent-to-a-liveview",level:2},{value:"LiveComponentSocket API",id:"livecomponentsocket-api",level:2}],c={toc:s};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"live-components"},"Live Components"),(0,i.kt)("p",null,"We've mostly been talking about LiveViews, but ",(0,i.kt)("strong",{parentName:"p"},"LiveViewJS")," also supports ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveComponents"),". Live Components are a way\nto create self-contained, stateful and stateless components that are reusable across multiple LiveViews. Live Components\nare a great way to break up your LiveView into smaller, reusable, more manageable pieces."),(0,i.kt)("h2",{id:"livecomponent-api"},"LiveComponent API"),(0,i.kt)("p",null,"LiveComponents have a much simpler API than LiveViews. They have the following methods all of which are optional except\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"render"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mount")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"update")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"handleEvent")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"render")," (required)")),(0,i.kt)("h3",{id:"stateful-vs-stateless"},"Stateful vs Stateless"),(0,i.kt)("p",null,"LiveComponents can be stateful or stateless. Stateful components are identified by passing an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property into the\n",(0,i.kt)("inlineCode",{parentName:"p"},"meta.live_component")," function in the LiveView. Stateless LiveComponents do not have an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property. Stateful\ncomponents are also the only type of LiveComponent that can receive events (and therefore have a ",(0,i.kt)("inlineCode",{parentName:"p"},"handleEvent")," method)."),(0,i.kt)("h3",{id:"lifecycle-differences"},"Lifecycle Differences"),(0,i.kt)("p",null,"Both types of LiveComponents have the same lifecycle methods. Both types initially follow the same execution flow when\nthey are first loaded:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"mount => update => render")),(0,i.kt)("p",null,"With Stateless LiveComponents, the execution flow above is the same for every render cycle. For Stateful LiveComponents,\nafter the first render cycle, the execution flow is:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"update => render")),(0,i.kt)("h3",{id:"stateful-livecomponent-handleevent"},"Stateful LiveComponent ",(0,i.kt)("inlineCode",{parentName:"h3"},"handleEvent")),(0,i.kt)("p",null,"Targeting a LiveComponent requires the addition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"phx-target")," attribute to a the rendered HTML element. Inside of a\n",(0,i.kt)("inlineCode",{parentName:"p"},"render")," a LiveComponent can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"meta.myself")," property in the ",(0,i.kt)("inlineCode",{parentName:"p"},"phx-target")," attribute to target itself. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<button phx-click="my_event" phx-target="${meta.myself}">Click Me</button>\n')),(0,i.kt)("p",null,"Alternatively, you can target another LiveComponent by passing the DOM id or class selector into the ",(0,i.kt)("inlineCode",{parentName:"p"},"phx-target"),"\nattribute. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<button phx-click="my_event" phx-target="#comp_3">Click Me</button>\n')),(0,i.kt)("p",null,"In either case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"handleEvent")," method will be called with the ",(0,i.kt)("inlineCode",{parentName:"p"},"my_event")," event prompting a re-render of the\nLiveComponent."),(0,i.kt)("h2",{id:"adding-a-livecomponent-to-a-liveview"},"Adding a LiveComponent to a LiveView"),(0,i.kt)("p",null,"To add a LiveComponent to a LiveView, you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewMeta")," ",(0,i.kt)("inlineCode",{parentName:"p"},"live_component")," function. The ",(0,i.kt)("inlineCode",{parentName:"p"},"live_component"),"\nfunction takes a LiveComponent along with a JSON object with an optional ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property is present,\nthe LiveComponent will be stateful. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property is not present, the LiveComponent will be stateless. For\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'...\nrender: (context, meta) => {\n  return html`\n    <div>\n      ${meta.live_component(MyStatefulComponent, {id: "comp_1", bar: "baz"})}\n      ${meta.live_component(MyStatefulComponent, {id: "comp_2"})}\n      ${meta.live_component(MyStatelessComponent, {foo: "bar"})}\n    </div>\n  `\n}\n...\n')),(0,i.kt)("h2",{id:"livecomponentsocket-api"},"LiveComponentSocket API"),(0,i.kt)("p",null,"Similar to LiveViews, LiveComponents have a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveComponentSocket")," API that is the utility belt for LiveComponents. Below\nis the API for LiveComponentSocket:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Represents the `LiveComponent`'s websocket connectedness along with current\n * state of the component.  Also provides a method for sending messages\n * internally to the parent `LiveView`.\n */\nexport interface LiveComponentSocket<\n  TContext extends LiveContext = AnyLiveContext,\n  TInfo extends LiveInfo = AnyLiveInfo\n> {\n  /**\n   * The id of the parent `LiveView`\n   */\n  id: string;\n  /**\n   * Whether the websocket is connected (i.e.,  http request or joined via websocket)\n   * true if connected to a websocket, false for http request\n   */\n  connected: boolean;\n  /**\n   * Read-only, current state of the `LiveComponent`\n   */\n  context: TContext;\n  /**\n   * helper method to send messages to the parent `LiveView` via the `handleInfo`\n   */\n  sendParentInfo(info: Info<TInfo>): void;\n  /**\n   * `assign` is used to update the `Context` (i.e.,  state) of the `LiveComponent`\n   */\n  assign(context: Partial<TContext>): void;\n  /**\n   * helper method to send events to Hooks on the parent `LiveView`\n   */\n  pushEvent(pushEvent: AnyLivePushEvent): void;\n}\n")))}m.isMDXComponent=!0}}]);