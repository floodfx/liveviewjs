"use strict";(self.webpackChunkliveviewjs_com=self.webpackChunkliveviewjs_com||[]).push([[3304],{876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},v=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),v=c(n),h=a,u=v["".concat(l,".").concat(h)]||v[h]||d[h]||i;return n?o.createElement(u,r(r({ref:t},p),{},{components:n})):o.createElement(u,r({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=v;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}v.displayName="MDXCreateElement"},2667:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=n(7896),a=(n(2784),n(876));const i={sidebar_position:2},r="LiveViewSocket API - Context",s={unversionedId:"liveview-socket/liveviewsocket-api-context",id:"liveview-socket/liveviewsocket-api-context",title:"LiveViewSocket API - Context",description:'The "context" of a LiveView is the current state of the LiveView. One way to think of a LiveView is as a set of methods',source:"@site/docs/04-liveview-socket/liveviewsocket-api-context.md",sourceDirName:"04-liveview-socket",slug:"/liveview-socket/liveviewsocket-api-context",permalink:"/docs/liveview-socket/liveviewsocket-api-context",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"LiveViewSocket API",permalink:"/docs/liveview-socket/liveviewsocket-api"},next:{title:"LiveViewSocket API - Push",permalink:"/docs/liveview-socket/liveviewsocket-api-push"}},l={},c=[{value:"Context Properties and Methods on the <code>LiveViewSocket</code>",id:"context-properties-and-methods-on-the-liveviewsocket",level:2},{value:"Details",id:"details",level:2},{value:"Context Type Annotations",id:"context-type-annotations",level:2},{value:"Context Persisted for the Life of the LiveView",id:"context-persisted-for-the-life-of-the-liveview",level:2},{value:"Temporary Data for Context",id:"temporary-data-for-context",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"liveviewsocket-api---context"},"LiveViewSocket API - Context"),(0,a.kt)("p",null,'The "context" of a LiveView is the current state of the LiveView. One way to think of a LiveView is as a set of methods\nthat handle events, read and write the context, and render a view based on the data in the context. Obviously,\nproperties and methods that manipulate the context are very important to a LiveView.'),(0,a.kt)("h2",{id:"context-properties-and-methods-on-the-liveviewsocket"},"Context Properties and Methods on the ",(0,a.kt)("inlineCode",{parentName:"h2"},"LiveViewSocket")),(0,a.kt)("p",null,"Three parts of the ",(0,a.kt)("inlineCode",{parentName:"p"},"LiveViewSocket")," are used to manipulate the context:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"context")," (property, read-only)"),(0,a.kt)("td",{parentName:"tr",align:null},"The current context (i.e.,  state) of the LiveView")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"assign(context:Partial<TContext>):void;")),(0,a.kt)("td",{parentName:"tr",align:null},"Update the context (i.e.,  state) of the LiveView")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"tempAssign(context:Partial<TContext>):void;")),(0,a.kt)("td",{parentName:"tr",align:null},"Marks any set properties as temporary and will be reset to the given value after the next render cycle. Typically used to ensure large but infrequently updated values are not kept in memory.")))),(0,a.kt)("h2",{id:"details"},"Details"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"socket.assign")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"socket.context")," are the work-horse methods for manipulating and reading the state of the LiveView.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"assign")," method is used to update the state of the LiveView and the ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," property is used to read the state of\nthe LiveView."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// Update the context (i.e.,  current state) of the `LiveView`\nsocket.assign({ foo: "bar" });\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// Read the context (i.e.,  current state) of the `LiveView`\nif (socket.context.foo === "baz") {\n  // do something\n}\n// or destructure data from the context\nconst { foo } = socket.context;\n')),(0,a.kt)("h2",{id:"context-type-annotations"},"Context Type Annotations"),(0,a.kt)("p",null,"When creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"LiveView"),", developers can provide a type annotation for ",(0,a.kt)("inlineCode",{parentName:"p"},"TContext"),' which describes the "shape" of the\ncontext for that LiveView. This is useful for providing type safety and autocomplete for the context (in Typescript).'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'\n// You can define the "shape" of the TContext by annotating the createLiveView function\nconst myLiveView = createLiveView<{foo: string}>(\n  mount: (socket) => {\n    socket.assign({ foo: "bar" });\n    ...\n    socket.assign({ baz: "qux" }); // type error no "baz" property in context\n  }\n  ...\n)\n')),(0,a.kt)("p",null,"You can type the Context inline as above or you can define the context type first and then use it as a type\nannotation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// Define the MyContext interface\ninterface MyContext { foo: string };\n// Annotate the createLiveView function with the MyContext interface\nconst myLiveView = createLiveView<MyContext>(...)\n")),(0,a.kt)("h2",{id:"context-persisted-for-the-life-of-the-liveview"},"Context Persisted for the Life of the LiveView"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," of a LiveView is persisted on the server (in memory by default) which means any data added to the\n",(0,a.kt)("inlineCode",{parentName:"p"},"context")," (via ",(0,a.kt)("inlineCode",{parentName:"p"},"assign"),") will be stored until that LiveView instance is cleaned up."),(0,a.kt)("h2",{id:"temporary-data-for-context"},"Temporary Data for Context"),(0,a.kt)("p",null,"Sometimes you want to add data to a ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," that is temporary ","\u2014",' that is, only added to the context for one\n"render cycle". There is a method called ',(0,a.kt)("inlineCode",{parentName:"p"},"socket.tempAssign")," that allows a developer to tell ",(0,a.kt)("strong",{parentName:"p"},"LiveViewJS")," to set a\n",(0,a.kt)("inlineCode",{parentName:"p"},"context")," property to a given value after the render cycle. Typically this is used for large objects or collections that\ndon't change often and therefore probably don't need to be stored in memory (e.g., collection of users or messages,\netc)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// first assign a large object to the context\nsocket.assign({ photos: [\n  ...// 10s, 100s, 1000s, of photos\n]});\n// use tempAssign to tell LiveViewJS to clear the photos array after this render cycle\nsocket.tempAssign({ photos: [] });\n")))}d.isMDXComponent=!0}}]);