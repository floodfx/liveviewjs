"use strict";(self.webpackChunkliveviewjs_com=self.webpackChunkliveviewjs_com||[]).push([[450],{876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,f=d["".concat(l,".").concat(u)]||d[u]||h[u]||r;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9409:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7896),o=(n(2784),n(876));const r={sidebar_position:7},i="Raw `LiveViewSocket` API",s={unversionedId:"liveview-socket/raw-liveviewsocket-api",id:"liveview-socket/raw-liveviewsocket-api",title:"Raw `LiveViewSocket` API",description:"For your reference, below is the raw Typescript for the LiveViewSocket interface (copied from",source:"@site/docs/04-liveview-socket/raw-liveviewsocket-api.md",sourceDirName:"04-liveview-socket",slug:"/liveview-socket/raw-liveviewsocket-api",permalink:"/docs/liveview-socket/raw-liveviewsocket-api",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"LiveViewSocket API - Misc",permalink:"/docs/liveview-socket/liveviewsocket-api-misc"},next:{title:"Lifecycle of a LiveView",permalink:"/docs/category/lifecycle-of-a-liveview"}},l={},c=[],p={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"raw-liveviewsocket-api"},"Raw ",(0,o.kt)("inlineCode",{parentName:"h1"},"LiveViewSocket")," API"),(0,o.kt)("p",null,"For your reference, below is the raw Typescript for the ",(0,o.kt)("inlineCode",{parentName:"p"},"LiveViewSocket")," interface (copied from\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/floodfx/liveviewjs/blob/main/packages/core/src/server/socket/liveSocket.ts"},"here"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="packages/core/src/server/socket/liveSocket.ts"',title:'"packages/core/src/server/socket/liveSocket.ts"'},"/**\n * Main interface to update state, interact, message, and otherwise\n * manage the lifecycle of a `LiveView`.\n *\n * The `LiveView` API (i.e.,  `mount`, `handleParams`, `handleInfo`, `handleEvent`)\n * are all passed `LiveViewSocket` which provide access to the current `LiveView`\n * context (via `context`) as well as various methods update the `LiveView` including\n * `assign` which updates the `LiveView`'s context (i.e.,  state).\n */\nexport interface LiveViewSocket<TContext extends LiveContext = AnyLiveContext, TInfos extends LiveInfo = AnyLiveInfo> {\n  /**\n   * The id of the `LiveView`\n   */\n  readonly id: string;\n  /**\n   * Whether the websocket is connected.\n   * true if connected to a websocket, false for http request\n   */\n  readonly connected: boolean;\n  /**\n   * The current context (i.e.,  state) of the `LiveView`\n   */\n  readonly context: TContext;\n  /**\n   * `assign` is used to update the context (i.e.,  state) of the `LiveComponent`\n   * @param context a `Partial` of the LiveView's context to update\n   */\n  assign(context: Partial<TContext>): void;\n  /**\n   * Marks any set properties as temporary and will be reset to the given\n   * value after the next render cycle.  Typically used to ensure large but\n   * infrequently updated values are not kept in memory.\n   *\n   * @param context a partial of the context that should be temporary and the value to reset it to\n   */\n  tempAssign(context: Partial<TContext>): void;\n  /**\n   * Updates the `<title>` tag of the `LiveView` page.  Requires using the\n   * `live_title` helper in rendering the page.\n   *\n   * @param newPageTitle the new text value of the page - note the prefix and suffix will not be changed\n   */\n  pageTitle(newPageTitle: string): void;\n  /**\n   * Pushes an event from the server to the client.  Requires a\n   * client `Hook` to be defined and to be listening for the event\n   * via `this.handleEvent` callback.\n   *\n   * @param pushEvent the event to push to the client\n   */\n  pushEvent(pushEvent: AnyLivePushEvent): void;\n  /**\n   * Updates the LiveView's browser URL with the given path and query parameters.\n   *\n   * @param path the path whose query params are being updated\n   * @param params the query params to update the path with\n   * @param replaceHistory whether to replace the current history entry or push a new one (defaults to false)\n   */\n  pushPatch(path: string, params?: URLSearchParams, replaceHistory?: boolean): Promise<void>;\n  /**\n   * Shutdowns the current `LiveView`and loads another `LiveView`in its place\n   * without reloading the whole page (i.e.,  making a full HTTP request).  Can be\n   * used to remount the current `LiveView`if need be. Use `pushPatch` to update the\n   * current `LiveView`without unloading and remounting.\n   *\n   * @param path the path whose query params are being updated\n   * @param params the query params to update the path with\n   * @param replaceHistory whether to replace the current history entry or push a new one (defaults to false)\n   */\n  pushRedirect(path: string, params?: URLSearchParams, replaceHistory?: boolean): Promise<void>;\n  /**\n   * Add flash to the socket for a given key and value.\n   * @param key the key to add the flash to\n   * @param value the flash value\n   */\n  putFlash(key: string, value: string): Promise<void>;\n  /**\n   * Runs the given function on the given interval until this `LiveView` is\n   * unloaded.\n   *\n   * @param fn the function to run on the interval\n   * @param intervalMillis the interval to run the function on in milliseconds\n   */\n  repeat(fn: () => void, intervalMillis: number): void;\n  /**\n   * Send an internal event (a.k.a \"Info\") to the LiveView's `handleInfo` method\n   *\n   * @param event the event to send to `handleInfo`\n   */\n  sendInfo(info: Info<TInfos>): void;\n  /**\n   * Subscribe to the given topic using pub/sub. Events published to this topic\n   * will be delivered to `handleInfo`.\n   *\n   * @param topic the topic to subscribe this `LiveView`to\n   */\n  subscribe(topic: string): Promise<void>;\n\n  /**\n   * Allows file uploads for the given `LiveView`and configures the upload\n   * options (filetypes, size, etc).\n   * @param name the name of the upload\n   * @param options the options for the upload (optional)\n   */\n  allowUpload(name: string, options?: UploadConfigOptions): Promise<void>;\n\n  /**\n   * Cancels the file upload for a given UploadConfig by config name and file ref.\n   * @param name the name of the upload from which to cancel\n   * @param ref the ref of the upload entry to cancel\n   */\n  cancelUpload(configName: string, ref: string): Promise<void>;\n\n  /**\n   * Consume the uploaded files for a given UploadConfig (by name). This\n   * should only be called after the form's \"save\" event has occurred which\n   * guarantees all the files for the upload have been fully uploaded.\n   * @param name the name of the upload from which to consume\n   * @param fn the callback to run for each entry\n   * @returns an array of promises based on the return type of the callback function\n   * @throws if any of the entries are not fully uploaded (i.e.,  completed)\n   */\n  consumeUploadedEntries<T>(\n    configName: string,\n    fn: (meta: ConsumeUploadedEntriesMeta, entry: UploadEntry) => Promise<T>\n  ): Promise<T[]>;\n\n  /**\n   * Returns two sets of files that are being uploaded, those `completed` and\n   * those `inProgress` for a given UploadConfig (by name).  Unlike `consumeUploadedEntries`,\n   * this does not require the form's \"save\" event to have occurred and will not\n   * throw if any of the entries are not fully uploaded.\n   * @param name the name of the upload from which to get the entries\n   * @returns an object with `completed` and `inProgress` entries\n   */\n  uploadedEntries(configName: string): Promise<{\n    completed: UploadEntry[];\n    inProgress: UploadEntry[];\n  }>;\n}\n")))}h.isMDXComponent=!0}}]);