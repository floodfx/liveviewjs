"use strict";(self.webpackChunkliveviewjs_com=self.webpackChunkliveviewjs_com||[]).push([[3380],{876:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>c});var n=a(2784);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),d=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},l=function(e){var t=d(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=d(a),c=i,k=h["".concat(p,".").concat(c)]||h[c]||m[c]||o;return a?n.createElement(k,r(r({ref:t},l),{},{components:a})):n.createElement(k,r({ref:t},l))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1200:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(7896),i=(a(2784),a(876));const o={sidebar_position:2},r="Changesets",s={unversionedId:"forms-and-changesets/changesets",id:"forms-and-changesets/changesets",title:"Changesets",description:"High Level",source:"@site/docs/07-forms-and-changesets/changesets.md",sourceDirName:"07-forms-and-changesets",slug:"/forms-and-changesets/changesets",permalink:"/docs/forms-and-changesets/changesets",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/forms-and-changesets/overview"},next:{title:"Forms & Changesets Example",permalink:"/docs/forms-and-changesets/use-with-forms"}},p={},d=[{value:"High Level",id:"high-level",level:2},{value:"Next Steps",id:"next-steps",level:2}],l={toc:d};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"changesets"},"Changesets"),(0,i.kt)("h2",{id:"high-level"},"High Level"),(0,i.kt)("p",null,"At a high level, Changesets are used to track creation and mutation of data models in LiveView projects and synchronize\nthem with HTML Forms and the user input that drives them."),(0,i.kt)("p",null,"Changeset are built on top of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/colinhacks/zod"},"Zod"),' which is a "Typescript-first schema validation\nwith static type inference" library.'),(0,i.kt)("p",null,"Let's go through the steps of creating a changeset helper for a Book data model."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"The ",(0,i.kt)("a",{parentName:"mdxAdmonitionTitle",href:"https://github.com/colinhacks/zod#basic-usage"},"basics of Zod")," are pretty easy to pick up especially if you"),(0,i.kt)("p",{parentName:"admonition"},"are familiar with Typescript. Even if you are not too familiar with Zod or Typescript, the concept is Zod is pretty\nstraight forward. Essentially you are defining a schema and then parsing the input data against the schema. If the input\ndata matches the schema then the data is valid. If the input data does not match the schema then the data is invalid and\nyou can use the error messages to display validation errors to the user. :::"),(0,i.kt)("h2",{parentName:"admonition",id:"create-a-zod-schema"},"Create a Zod Schema"),(0,i.kt)("p",{parentName:"admonition"},"First, we need to define a Zod schema for the data model:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\n\n// Use Zod to define the schema for the Book model\nconst BookSchema = z.object({\n  id: z.string().default(nanoid),\n  name: z.string().min(2).max(100),\n  author: z.string().min(2).max(100),\n  checked_out: z.boolean().default(false),\n});\n')),(0,i.kt)("p",{parentName:"admonition"},"As you can see the ",(0,i.kt)("inlineCode",{parentName:"p"},"BookSchema")," has an ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"genre")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"checked_out")," property. The ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," is a string and is\ngenerated using the ",(0,i.kt)("inlineCode",{parentName:"p"},"nanoid")," function by default. The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"author")," are strings and must be at least 2 characters\nlong and no more than 100 characters long. The ",(0,i.kt)("inlineCode",{parentName:"p"},"checked_out")," property is a boolean and is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," by default."),(0,i.kt)("h2",{parentName:"admonition",id:"infer-the-type-based-on-the-schema"},"Infer the Type based on the Schema"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// infer the Book type from the schema\ntype Book = z.infer<typeof BookSchema>;\n")),(0,i.kt)("p",{parentName:"admonition"},"Now, we have a schema and a type for the Book data model. The ",(0,i.kt)("inlineCode",{parentName:"p"},"z.infer")," function is used to infer a valid type from the\nschema."),(0,i.kt)("p",{parentName:"admonition"},"So far this is basic Zod usage. Now that we have the schema and type we can use them to create a\n",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory"),"."),(0,i.kt)("h2",{parentName:"admonition",id:"generate-a-liveviewchangesetfactory"},"Generate a LiveViewChangesetFactory"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { newChangesetFactory } from "liveviewjs";\n\n// generate changeset factory\nconst bookCSF = newChangesetFactory<Book>(BookSchema);\n')),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"newChangesetFactory")," function takes a Zod schema (and type annotation) and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," for\nthat schema and type. The ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," is used to create ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset"),"s for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," model."),(0,i.kt)("h2",{parentName:"admonition",id:"using-a-liveviewchangesetfactory"},"Using a LiveViewChangesetFactory"),(0,i.kt)("p",{parentName:"admonition"},"Despite it's long name, a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," is simply a function that takes two ",(0,i.kt)("inlineCode",{parentName:"p"},"Partial"),"s and an (optional)\naction string and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset"),". The first ",(0,i.kt)("inlineCode",{parentName:"p"},"Partial")," is the starting data model and the second ",(0,i.kt)("inlineCode",{parentName:"p"},"Partial"),"\nis the changes to the data model."),(0,i.kt)("p",{parentName:"admonition"},"Here is the signature of the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A factory for creating a changeset for a given existing data model, updated data model, and optional action.\n */\nexport type LiveViewChangesetFactory<T> = (\n  existing: Partial<T>,\n  newAttrs: Partial<T>,\n  action?: string\n) => LiveViewChangeset<T>;\n")),(0,i.kt)("p",{parentName:"admonition"},"When you generate a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," for a given schema and type, the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory"),' is created\n(and "typed") for that schema and type. So, if you generate a ',(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," schema and type,\nthen the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," will be typed to a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," model and will only accept\n",(0,i.kt)("inlineCode",{parentName:"p"},"Partial<Book>"),"s as the first and second arguments."),(0,i.kt)("h2",{parentName:"admonition",id:"use-a-liveviewchangesetfactory-to-create-a-liveviewchangeset"},"Use a LiveViewChangesetFactory to create a LiveViewChangeset"),(0,i.kt)("p",{parentName:"admonition"},"Now that we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," model, we can use it to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," for a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," data."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const bookData: Partial<Book> = {\n  name: "The Hobbit",\n  author: "J.R.R. Tolkien",\n};\n// create a new changeset for a new book\nconst bookCS = changeset({}, bookData, "create");\n')),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"bookCS")," object is a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," model. Zod parsed and validated the ",(0,i.kt)("inlineCode",{parentName:"p"},"bookData")," we passed in."),(0,i.kt)("p",{parentName:"admonition"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," has the following properties:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"valid: boolean")," - does the resulting merged data model pass all validation rules?"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"changes: Partial<T>")," - just the parts of the model that have been changed relative to the existing model"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data: T")," - the data model after the changeset has been applied (which may be invalid or valid depending on the\nvalidations)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"errors: { [Property in keyof T]?: string | undefined; }")," - an object that maps property names to error messages if\nthe changeset has invalid data"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"action?: string")," - the changeset action (or undefined if unset)")),(0,i.kt)("p",{parentName:"admonition"},"So now that we've created a ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," for the book data we can ask it if the data is valid or not:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"bookCS.valid; // => true\n")),(0,i.kt)("p",{parentName:"admonition"},"Then we can ask it for the new data:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'bookCS.data; // => { id: "some-random-id", name: "The Hobbit", author: "J.R.R. Tolkien", checked_out: false }\n')),(0,i.kt)("h2",{parentName:"admonition",id:"invalid-data"},"Invalid Data"),(0,i.kt)("p",{parentName:"admonition"},"Let's create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," for a book with invalid data:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const invalidBookData: Partial<Book> = {\n  name: "a",\n  author: "b",\n};\n// create a new changeset for this book\nconst invalidBookCS = changeset({}, invalidBookData, "create");\n')),(0,i.kt)("p",{parentName:"admonition"},"Now, we can ask the ",(0,i.kt)("inlineCode",{parentName:"p"},"invalidBookCS")," if it is valid:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"invalidBookCS.valid; // => false\n")),(0,i.kt)("p",{parentName:"admonition"},"And we can ask it for the errors:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'invalidBookCS.errors; // => { name: "Must be at least 2 characters", author: "Must be at least 2 characters" }\n')),(0,i.kt)("h2",{parentName:"admonition",id:"what-about-the-action-string"},"What about the action string?"),(0,i.kt)("p",{parentName:"admonition"},"The value of the action string has no significance in an of itself. The presence of the action string however does\nimpact the ",(0,i.kt)("inlineCode",{parentName:"p"},"valid")," property of the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangeset")," returned by the ",(0,i.kt)("inlineCode",{parentName:"p"},"LiveViewChangesetFactory"),". ",(0,i.kt)("strong",{parentName:"p"},"If the action\nstring is NOT set")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"valid")," property will always return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". ",(0,i.kt)("strong",{parentName:"p"},"If the action string IS set")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"valid")," property\nwill return ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the data is valid and ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," if the data is invalid.")),(0,i.kt)("p",null,'would be errors on the form when the page is first loaded. "Empty" changesets are always valid. :::'),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,'Now that you understand "Changesets", we can show you how they are powerful partners with the Form Events we discussed\nearlier.'))}m.isMDXComponent=!0}}]);